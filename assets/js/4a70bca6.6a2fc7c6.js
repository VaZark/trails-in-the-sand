"use strict";(self.webpackChunktil_remaster=self.webpackChunktil_remaster||[]).push([[2597],{3905:function(e,t,r){r.d(t,{Zo:function(){return c},kt:function(){return h}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function l(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?l(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):l(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},l=Object.keys(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),d=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=d(r),h=a,f=u["".concat(s,".").concat(h)]||u[h]||p[h]||l;return r?n.createElement(f,i(i({ref:t},c),{},{components:r})):n.createElement(f,i({ref:t},c))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=r.length,i=new Array(l);i[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var d=2;d<l;d++)i[d]=r[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},5457:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return c},default:function(){return u}});var n=r(7462),a=r(3366),l=(r(7294),r(3905)),i=["components"],o={},s="Prefetching",d={unversionedId:"django/db/Prefetching",id:"django/db/Prefetching",title:"Prefetching",description:"Prefetching is when the queryset pulls in and populates related fields. This is primarily done to overcome the 1+N problem where multiple db requests are made when iterating over an queryset that has related fields in it. Django ORM gives rise to this problem as the querysets are lazy. The laziness is useful when the application apply / alter conditions over the existing queryset but it gives rise to cumbersome and wasteful IO calls when dealing with models with related fields.",source:"@site/docs-python/django/db/Prefetching.md",sourceDirName:"django/db",slug:"/django/db/Prefetching",permalink:"/docs-python/django/db/Prefetching",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Onboarding existing tables",permalink:"/docs-python/django/db/Onboarding existing tables"},next:{title:"Querysets",permalink:"/docs-python/django/db/Querysets"}},c=[{value:"select_related",id:"select_related",children:[],level:2},{value:"prefetch_related",id:"prefetch_related",children:[],level:2},{value:"TLDR",id:"tldr",children:[],level:2}],p={toc:c};function u(e){var t=e.components,r=(0,a.Z)(e,i);return(0,l.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"prefetching"},"Prefetching"),(0,l.kt)("p",null,"Prefetching is when the queryset pulls in and populates related fields. This is primarily done to overcome the 1+N problem where multiple db requests are made when iterating over an queryset that has related fields in it. Django ORM gives rise to this problem as the querysets are lazy. The laziness is useful when the application apply / alter conditions over the existing queryset but it gives rise to cumbersome and wasteful IO calls when dealing with models with related fields."),(0,l.kt)("p",null,"This becomes even more trickier and wasteful when we are deling with nested loops and/or multiple related fields."),(0,l.kt)("p",null,"In order to avoid all the wasteful processing, we pull in all the related fields when invoking the queryset. This is called prefetching, we use two methods to enforce the same"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"prefetch_related"),(0,l.kt)("li",{parentName:"ul"},"select_related")),(0,l.kt)("h2",{id:"select_related"},"select_related"),(0,l.kt)("p",null,"It pulls all the related fields in a single query. It uses a ",(0,l.kt)("inlineCode",{parentName:"p"},"JOIN")," to merge the tables"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"queryset.select_related() # joins with all the tables that related to the model\nqueryset.select_related('field_1') # joins with the table referenced by field_1\nqueryset.select_related('field_1','field_2') # joins with the tables referenced by field_1 and field_2\n")),(0,l.kt)("h2",{id:"prefetch_related"},"prefetch_related"),(0,l.kt)("p",null,"It executes the base queryset, make a list of the values that are pointed by the related field of the model. It then runs a separate query for each table referene by the related fields. This pulls all the data required for the related fields with separate queries only once per queryset (vs calling it for each object). Finally,  the joins are performed in-memory."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Why use ",(0,l.kt)("em",{parentName:"strong"},"prefetch_related"))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"It can handle Many-to-Many and Many-to-One relationships (vs following a ForeignKey)"),(0,l.kt)("li",{parentName:"ul"},"It never fetches duplicated data as the referenced rows are called once and joined in-memory. This is a huge perfomance gain when dealing with many-to-many relationships.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"from django.db.models import Prefetch\n\nqueryset.prefetch_related() # retrieves data from all the tables that related to the model\nqueryset.prefetch_related(Prefetch(\n            'Related_Set',\n            queryset=Related_Model.objects.filter()\n            ) # Reduces to two queries even dealing with conditions for related_field\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Prefetch")," helps us avoid creating new queries when applying conditions on a the prefetched field. This problem is inherent to the implmentaton and logic of prefetch_related, thus Preftch allows us to deal with it by pulling it in when performing the prefetch. We can store the results in separate field with",(0,l.kt)("inlineCode",{parentName:"p"},"to_attr")," of the ",(0,l.kt)("em",{parentName:"p"},"Prefetch")," constructor."),(0,l.kt)("h2",{id:"tldr"},"TLDR"),(0,l.kt)("p",null,"It varies by situation whether ",(0,l.kt)("inlineCode",{parentName:"p"},"select_related()")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"prefetch_related()")," is optimal. Sometimes, it may even be optimal to mix and match the two."),(0,l.kt)("p",null,"If in doubt, use ",(0,l.kt)("inlineCode",{parentName:"p"},"prefetch_related()"),". It's queries are unlikely to be much more expensive than ",(0,l.kt)("inlineCode",{parentName:"p"},"select_related()")," in most usecases."))}u.isMDXComponent=!0}}]);